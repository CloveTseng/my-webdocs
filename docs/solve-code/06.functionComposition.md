---
title: "2629.Function Composition"
authors: [clove]
tags: [JavaScript, solving, easy]
---
:::note
為個人思考的思緒紀錄，可能有更優解法，歡迎指教討論共好
:::

:::tip[Topic]
[30 Days of JavaScript](https://leetcode.com/problems/function-composition/description/?envType=study-plan-v2&envId=30-days-of-javascript)
:::

## 思考問題
1. 要組一個函數組來運算
2. ~~建一個空陣列，準備存放各別函數~~ 不需要，直接用 functions 就好
3. 如果陣列長度是 0 ，回傳 x 的值
4. 執行陣列順序是從右到左，並且運算的值會傳到下一個函數
5. 陣列可以從右到左嗎？可以，用 i  - - 的方式
6. 是不是要先設一個空值，來存放每一次的結果
7. 跑一個函數，回傳結果給 x，修改 x 

## 寫 pseudocode
1. ~~SET empty array~~
2. IF array.length less than or equal to 0 , print x
3. SET result to x
4. FOR loop i subtraction subtraction
5. ~~x to init~~ (改到 for 外面)
6. 後面就不會了

# Solve
```js
var compose = function(functions) {
  return function(x) {
    if (functions === 0 ) {
     return x;
    }
    let result = x;
    for (let i = functions.length -1 ; i >= 0; i - -) {
        const currentFunc = functions[i];
        result = currentFunc(result);
    }
    return result;
  }
}
```
使用 reduceRight 的寫法
```js
var compose = function(functions) {
  return function(x) {
    return functions.reduceRight((acc, fn) => fn(acc), x);
  }
};
```

## 反思與優化
- 最前面處理如果 function 是空，回傳 x (是對的)
- 並且想到一個變數來儲存累積的結果方向也是對的
- for 迴圈有一點錯誤：原本寫 `i = functions.length +1` ，實際上應該是 `-1` ；迴圈條件：`i = 0` 是一個賦值操作，i 會變成 0 ，最後迴圈完全不會執行，所以應該是比較值 `i >= 0` 
- `const currentFunc = functions[i]` 跑迴圈的時候，(例如) 第一次 i 是 2 ，所以 currentFunc 就是陣列 2 的函式
- 接著再將 currentFunc(x) 進行 x 的運算，再回傳出來 `result = currentFunc(result)` 
- 有一個 methods 就是用來從右到左累積運算的 reduceRight 
又忘記 return
- 這裡 `let result = x` 要放在迴圈外面儲存變數(因為作用域與生命週期的關係)